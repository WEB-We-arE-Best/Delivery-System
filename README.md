# Delivery-System

AI를 활용한 대규모 배달 시스템

## 💻 기술 스택

- Language: Java 17
- Framework: Spring boot 3.x
- cloud: Spring Eureka
- Repository: MySql, MongoDB, Redis
- Messaging: Kafka
- Build Tool: Gradle 8.x
- Monitoring: Grafana, Prometheus
- CI: GitHub Action
- Deploy: ECR, EC2

## ✈️ 실행 방법

### 인프라 실행

```shell
docker compose -f infra-compose.yml up -d
```

### 서비스 실행

```shell
./build_service.sh
docker compose up -d
```

### 환경 변수

환경 변수 정보는
`.env.example` 파일을 확인해주세요

## 💾 인프라 설계도
![image](https://github.com/user-attachments/assets/d5fca4d2-7f91-4fb8-b440-93aa1eb19fb2)



## 🛵 주요 기능

### SAGA 패턴을 이용한 분산 트랜잭션 구현

- 배달이 30분 내에 배차되지 않으면 실패한 트랜잭션으로 간주하고 배달 취소 이벤트를
  `delivery-rollback` 토픽에 발행합니다.
- 매 1분마다 스케줄러가 실행되어 30분이 지난 배달 건을 조회하고 이를 취소 처리합니다.
- 이 이벤트는 주문 서비스의 `deliveryConsumer`가 받아 롤백을 처리하며, 다른 서비스에 이 사실을 알릴 수 있도록 합니다.

### Redis Geo를 이용한 위치 기반 가게 검색 시스템

- Redis Geo는 공간 데이터(위도 및 경도)를 효율적으로 저장하고 검색할 수 있도록 설계되어 있으므로 이를 이용해서 유저의 위치 일정 반경 내의 가게를 신속하게 조회함으로써
  포장 주문 가게를 조회하는 기능으로 이용

### 주문 생성 시 배달 생성

- CQRS 패턴에서는 명령(Command)과 조회(Query)를 분리하는데, MongoDB는 조회 성능을 최적화하기 위해 사용됩니다.
- MongoDB는 데이터를 읽을 때 높은 성능을 제공해, 관계형 DB에서 발생하는 복잡한 조인이나 N+1 문제를 피할 수 있어 대규모 데이터를 처리할 때도 성능을 유지합니다.
- MongoDB는 단순한 키-값 조회뿐만 아니라 복잡한 질의도 Criteria를 사용해 다양한 조건으로 필터링할 수 있으며, 복잡한 조회 작업에도 성능 저하 없이 처리가
  가능합니다.

### Sorted Set 및 Kafka를 사용해서 쿠폰 비동기 발급 기능

- Redis의 Sorted Set 기능을 이용해서 입력을 받은 시간을 기준으로 정렬을 진행함으로써 대기번호를 구현
- Sorted Set에 값을 넣기 전에 미리 확인해서 이미 대기 중인 유저의 진입을 방지
- 쿠폰 발급 가능 여부 확인 후 요청들은 모두 Kafka로 데이터를 전달

### 분산락을 이용한 쿠폰 개수 일관성 유지

- 쿠폰 발급 메서드에 AOP로 분산 락을 적용하여 동시에 여러 요청이 들어와도 필드 값의 일관성을 유지하도록 구성

## 📠 기술적 의사 결정

<details> <summary>멀티 모듈에서 공통 주소 처리</summary><br>

### 고민 했던 사항

서비스 모듈 간 주소 선택 기준으로 정부에서 제공하는 법정동 ID를 사용하기로 결정했습니다. 이에 따라 주소 정보를 각 모듈 간에 어떻게 관리할 지 고민을 하였습니다.

- **별도의 서버 생성**: 다른 모듈에서 사용하는 주소를 위해 서버를 생성
- **CSV 파일 개별 관리**: 각 모듈에서 별도로 CSV파일을 관리

그러나 이번 프로젝트를 MSA로 구성을 하면서 이미 여러 서버가 존재하는 상황에서 공통 주소 처리를 위한 서버를 하나 더 추가하는 것은 부담이 될 것으로 판단 되었고 CSV 파일이
변경될 때마다 모든 서비스에서 동일한 작업을 반복해야 하는 것은 비효율적이라 판단되었습니다.

CSV파일이 5MB 정도이고 전체 라인도 5만라인으로 한 번 순회하는 데도 0.1초도 안걸리기 때문에 이에 대한 대안으로 멀티 모듈 공통 라이브러리를 사용해서 CSV 파일을 통합
관리하는 방안으로 결정하였습니다.

### 기술적 결정 사항

openCSV를 사용해서 저장된 CSV파일을 메모리로 읽어 온다.

```java
private final ResourceLoader resourceLoader;

Resource resource = resourceLoader.getResource("classpath:" + ADDRESS_CSV);

CSVReader reader = new CSVReader(
    new InputStreamReader(resource.getInputStream(), Charset.forName("EUC-KR")));

List<String[]> strings = reader.readAll();
this.addressSetList =strings.

subList(1,strings.size());
```

이후 주소 목록의 저장방식을 `code: 주소정보` 의 Map 형식으로 보관하여서 code로도 접근할 수 있고 `values` method를 이용한 목록 접근으로도 가능하게
하였다.
</details><br>

<details> <summary>CQRS 패턴을 이용 조회 성능 향상</summary><br>

- CQRS를 주문 서비스에 적용한 이유는 명령(Command)와 조회(Query)의 책임을 분리함으로써 각 작업의 성능을 최적화하기 위함이다. 주문 시스템에서는 대규모 트랜잭션
  처리와 대량의 조회 요청이 발생하는데, 조회시 대량의 데이터를 빠르게 검색할 수 있는 MongoDB를 사용하여, 복잡한 조인과 N+1 문제를 피하고 조회 성능을 높일 수 있다.
    - 많은 Nosql중 mongoDB를 사용한 이유
        - MongoDB는 단순한 키-값 조회뿐 아니라 복잡한 질의(Query)를 지원한다. Criteria를 사용하여 다양한 조건 기반의 필터링을 지원하며, 복잡한 조회
          작업에도 성능 저하 없이 다양한 쿼리 옵션을 제공할 수 있기 때문에 MongDB를 채택 했다. 쿼리성능이 월등히 뛰어난 elasticSearch도 있었지만
          환경세팅 등을 고려하였을때 가장 러닝커브가 적은 mongoDB가 적합하다고 판단했습니다. 이후엔 elasticSearch를 공부하여 적용할 예정이다.
    - **CQRS에서 Kafka의 활용(RDS와 Nosql 데이터 동기화)**
        - create, update등의 command 관련 서비스가 실행 되었을 때 kafka의 이벤트를 동시에 보내 mongoDB에 save하는 방법을 사용하였다.
          CDC(Change Data Capture)로 RDS에서 데이터의 변경을 감지하고 이벤트 처리를 하는 방법을 채택해야 kafka에서 문제가 생겼을 때 데이터
          정합성 측면에서 더 좋지만 debizium 등 복잡한 환경세팅의 어려운점을 반영하여 이렇게 처리 하였다.

</details><br>
<details> <summary>SAGA 패턴을 이용한 롤백 처리</summary><br>

- SAGA 패턴을 사용하여 배달 시스템에서 롤백 처리를 구현한 이유는 **분산 트랜잭션에서 데이터 일관성을 유지**하기 위함이다. 예를 들어, 배달이 30분 내에 배차되지 않을
  경우 배달이 취소되는데, 이때 **알림 서비스나 주문 서비스**의 상태도 변경되어야 한다. SAGA 패턴의 **보상 트랜잭션**을 통해 실패한 트랜잭션에 대한 상태를 되돌리고,
  전체 시스템의 **데이터 무결성**을 보장할 수 있다.
    - kafka를 선택한 이유
        - 배달 취소와 같은 롤백 처리는 비동기적으로 처리되며, `delivery-rollback` 토픽을 통해 이벤트 기반으로 서비스 간 통신이 이루어진다. 이를 통해
          서비스 간 강한 결합을 피하면서 유연하게 트랜잭션을 관리할 수 있다.

</details><br>
<details> <summary>Redission을 사용해서 분산락 처리</summary><br>

### 분산락의 적용 이유

**비관적락**

- 데이터를 읽고 수정하는 동안 다른 트랜잭션이 접근하지 못하게 함
- 동시성 문제가 발생할 가능성이 높지만 성능 저하가 발생할 수 있다.

**낙관적락**

- 업데이트 시점에 데이터의 변경 여부를 확인하고 변경되었는 지 검증한다.
- 락을 걸지 않기 때문에 성능이 우수하나 충돌이 발생하면 롤백 및 재시도를 해야 한다.

**분산 락**

- 분산 시스템을 활용해서 락을 관리함으로써 동일한 리소스에 접근할 때 충돌을 방지함
- 여러 인스턴스 간에 동시성 문제를 해결할 수 있으나 분산 시스템이 장애가 생기면 문제가
  발생할 수 있다.

이번에 락을 적용할 부분은 쿠폰 재고의 일관성을 유지하기 위함으로 충돌이 잦게 발생할 거라 예상이 되므로 낙관적락은 제외 하였습니다.

MSA 환경에서 여러 인스턴스가 동일한 DB에 접근하므로 DB 자체에 락을 걸 경우 성능 저하가 발생할 수 있습니다.

위의 이유로 Redis를 사용한 분산락을 도입하기로 하였습니다.

### Redission 라이브러리를 사용한 이유

Spring에서는 Redis를 사용할 때, 주로 Lettuce와 Redisson 라이브러리를 사용합니다.

- Lettuce는 가벼우며 빠른 성능을 제공하기 때문에, 일반적인 캐싱 용도에 적합합니다.
- Redisson은 분산 락 기능을 보다 안정적으로 제공합니다.

락 구현의 차이점:

- Lettuce는 락을 구현할 때 SETNX 명령어를 사용하며, Spin Lock 방식으로 지속적으로 Redis에 요청을 보내 락을 확보합니다. 이 방식은 간단하지만, 네트워크
  부하가 발생할 수 있습니다.
- Redisson은 RedLock 알고리즘을 사용하며, Pub/Sub 구조로 락을 관리합니다. 이 방식은 네트워크 부하를 줄이고 더 안정적인 분산 락을 제공합니다.

위의 이유로 락 구현에 더 효율적으로 구현하는 Redission 라이브러리를 선택하였습니다.

</details><br>
<details> <summary>Redis와 Kafka를 사용한 카트 관리</summary><br>

### Redis 사용 이유

장바구니 기능으로는

- 제품에 대해 장바구니 추가
- 기존 제품을 다시 추가하면 수량 증가, 같은 매장의 다른 제품을 추가하면 해당 제품 추가
- 새로운 가게의 제품을 추가하면 기존 데이터 삭제 및 신규 추가

이에 따라 DB를 구성해야 했는데 MYSQL를 통해 진행하게 되면 데이터 용량도 증가하고 제품에 따른 수량 증가 및 제품 추가부분에서도 많은 쿼리문을 작업하게 되어 시간이 많은
필요하게 된다. 따라서 인메모리 데이터베이스인 Redis를 사용하여 구현하도록 하였다.

### Kafka 사용 이유

현재 물건을 장바구니에 담기 위해서는 물건 상세정보 End Point에서 담아야 하는데 User와 Product서비스는 별도의 서비스이므로 Product서비스에서 장바구니에 넣는
이벤트가 발생 시 User쪽에서 장바구니를 생성해줘야 한다.

따라서 이를 위해 Kafka를 통해 Product서비스에서 제품을 장바구니에 담는 End Point가 동작하는 이벤트 발생 시 User쪽에서 해당 데이터를 가져와 해당 유저에 대해
장바구니 데이터를 Redis에 저장하도록 구현하여 FeignClient를 통해 진행하는 것보다 속도 향상이 되었고, 동시성 처리도 가능하기에 사용하게 되었다.

</details><br>
<details> <summary>Redis Geo를 이용한 가게 검색</summary><br>

Redis Geo를 이용한 가게 검색은 위치 기반 서비스에서 효율적으로 가게를 조회하는 기능을 제공한다. Redis Geo는 위도와 경도 데이터를 저장하고 검색할 수 있는 기능을
제공하며, 특정 위치에서 일정 반경 내에 있는 가게를 매우 빠르게 찾을 수 있다. 이를 통해 사용자는 자신의 위치를 기준으로 가까운 가게를 신속하게 조회할 수 있다.

### Redis Geo를 이용한 가게 검색의 주요 기능

1. 위치 정보 저장: Redis Geo는 가게의 위도와 경도를 기반으로 좌표 데이터를 저장한다. 각 가게는 고유의 ID와 함께 위치 정보로 저장되며, 이를 통해 나중에 위치 기반
   검색이 가능해진다.
2. **반경 내 검색**: 사용자는 자신의 위치(위도, 경도)를 기준으로 **일정 반경 내에 있는 가게를 검색**할 수 있다. Redis의 `GEORADIUS`  명령어를 사용해
   특정 반경 내의 가게 목록을 빠르게 반환한다.
3. **빠른 응답 속도**: Redis의 인메모리 데이터 처리 특성 덕분에 위치 기반 조회 속도가 매우 빠르다. 이는 사용자 경험을 개선하고 실시간으로 가게 정보를 제공하는 데
   적합하다.

</details>

## 🐶 구성원

| 이름                                                 | 역할 분담                                                                                                                                                                                                                                                                                                                                           |
|----------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [김수봉](https://github.com/bongbongbon) &nbsp;&nbsp; | **주문**: CQRS 패턴으로 N+1 문제 해결 <br> Kafka로 MongoDB와 MySQL 동기화 <br> **배달**: SAGA 패턴으로 30분 이상 배차 실패 시 롤백 메시지 전송                                                                                                                                                                                                                                      |
| [배지원](https://github.com/Bae-Ji-Won)               | ▶ Auth <br>- 이메일 인증 기능 구현(유저 인증 고도화) <br>- Refresh Token 사용(토큰 탈취 위험 보완)  <br>- Redis를 활용 블랙리스트 기능 구현(로그아웃 기능 구현) <br>▶ User <br>- GeoCoding을 통한 유저 주소 위/경도 추출 <br>- Redis & Kafka를 통한 장바구니 기능 구현                                                                                                                                               |
| [김형철](https://github.com/shurona)                  | ▶ 공통 모듈 구성 <br>- 멀티 모듈 구조로 기본 레포 구성 <br>- 공통 주소 정보 처리 위한 csv 리더 라이브러리 구성 <br>▶ 쿠폰 모듈 <br>-  Kafka를 사용한 대규모 트래픽 처리 <br>- Sorted Set을 사용해서 클라이언트 대기 번호 조회 <br>▶ 라이더 모듈  <br>- 라이더 CRUD <br>▶ 배포 설정 <br>- Docker-compose 및 CI 설정 <br>- EC2 및 ECR을 사용한 배포 및 인프라 설정 <br>- coupon모듈에 grafana 및 prometheus 설정 <br>▶ 로그 설정 <br>- ELK를 이용해서 로그를 검색하도록 설정 |
| [유수인](https://github.com/jjong52)                  | ▶ STORE (상점) <br>- 배달 주문 가능 가게 조회 <br>법정동 코드로 가게 주인이 배달 가능 구역을 등록 / 유저의 주소가 배달 가능 구역에 포함되는 경우에만 가게가 조회되도록 구현 <br>- 포장 주문 가게 조회 <br>Redis Geo로 유저의 위치에서 일정 반경 내 가게만 조회되도록 구현 <br>▶ PRODUCT (상품) <br>- 가게주인이 상품을 등록하고 수정하는 기능 <br>▶ CATEGORY (카테고리) <br>- 관리자가 카테고리를 등록하고 수정하는 기능 <br>- 카테고리별 가게 조회 기능                                            |


